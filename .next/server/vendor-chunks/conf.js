"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/conf";
exports.ids = ["vendor-chunks/conf"];
exports.modules = {

/***/ "(rsc)/./node_modules/conf/dist/source/index.js":
/*!************************************************!*\
  !*** ./node_modules/conf/dist/source/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _a, _b;\nvar _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst dotProp = __webpack_require__(/*! dot-prop */ \"(rsc)/./node_modules/dot-prop/index.js\");\nconst pkgUp = __webpack_require__(/*! pkg-up */ \"(rsc)/./node_modules/pkg-up/index.js\");\nconst envPaths = __webpack_require__(/*! env-paths */ \"(rsc)/./node_modules/env-paths/index.js\");\nconst atomically = __webpack_require__(/*! atomically */ \"(rsc)/./node_modules/atomically/dist/index.js\");\nconst ajv_1 = __webpack_require__(/*! ajv */ \"(rsc)/./node_modules/ajv/dist/ajv.js\");\nconst ajv_formats_1 = __webpack_require__(/*! ajv-formats */ \"(rsc)/./node_modules/ajv-formats/dist/index.js\");\nconst debounceFn = __webpack_require__(/*! debounce-fn */ \"(rsc)/./node_modules/debounce-fn/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst onetime = __webpack_require__(/*! onetime */ \"(rsc)/./node_modules/onetime/index.js\");\nconst encryptionAlgorithm = 'aes-256-cbc';\nconst createPlainObject = () => {\n    return Object.create(null);\n};\nconst isExist = (data) => {\n    return data !== undefined && data !== null;\n};\nlet parentDir = '';\ntry {\n    // Prevent caching of this module so module.parent is always accurate.\n    // Note: This trick won't work with ESM or inside a webworker\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete __webpack_require__.c[__filename];\n    parentDir = path.dirname((_b = (_a = module.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : '.');\n}\ncatch (_c) { }\nconst checkValueType = (key, value) => {\n    const nonJsonTypes = new Set([\n        'undefined',\n        'symbol',\n        'function'\n    ]);\n    const type = typeof value;\n    if (nonJsonTypes.has(type)) {\n        throw new TypeError(`Setting a value of type \\`${type}\\` for key \\`${key}\\` is not allowed as it's not supported by JSON`);\n    }\n};\nconst INTERNAL_KEY = '__internal__';\nconst MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;\nclass Conf {\n    constructor(partialOptions = {}) {\n        var _a;\n        _Conf_validator.set(this, void 0);\n        _Conf_encryptionKey.set(this, void 0);\n        _Conf_options.set(this, void 0);\n        _Conf_defaultValues.set(this, {});\n        this._deserialize = value => JSON.parse(value);\n        this._serialize = value => JSON.stringify(value, undefined, '\\t');\n        const options = {\n            configName: 'config',\n            fileExtension: 'json',\n            projectSuffix: 'nodejs',\n            clearInvalidConfig: false,\n            accessPropertiesByDotNotation: true,\n            configFileMode: 0o666,\n            ...partialOptions\n        };\n        const getPackageData = onetime(() => {\n            const packagePath = pkgUp.sync({ cwd: parentDir });\n            // Can't use `require` because of Webpack being annoying:\n            // https://github.com/webpack/webpack/issues/196\n            const packageData = packagePath && JSON.parse(fs.readFileSync(packagePath, 'utf8'));\n            return packageData !== null && packageData !== void 0 ? packageData : {};\n        });\n        if (!options.cwd) {\n            if (!options.projectName) {\n                options.projectName = getPackageData().name;\n            }\n            if (!options.projectName) {\n                throw new Error('Project name could not be inferred. Please specify the `projectName` option.');\n            }\n            options.cwd = envPaths(options.projectName, { suffix: options.projectSuffix }).config;\n        }\n        __classPrivateFieldSet(this, _Conf_options, options, \"f\");\n        if (options.schema) {\n            if (typeof options.schema !== 'object') {\n                throw new TypeError('The `schema` option must be an object.');\n            }\n            const ajv = new ajv_1.default({\n                allErrors: true,\n                useDefaults: true\n            });\n            (0, ajv_formats_1.default)(ajv);\n            const schema = {\n                type: 'object',\n                properties: options.schema\n            };\n            __classPrivateFieldSet(this, _Conf_validator, ajv.compile(schema), \"f\");\n            for (const [key, value] of Object.entries(options.schema)) {\n                if (value === null || value === void 0 ? void 0 : value.default) {\n                    __classPrivateFieldGet(this, _Conf_defaultValues, \"f\")[key] = value.default;\n                }\n            }\n        }\n        if (options.defaults) {\n            __classPrivateFieldSet(this, _Conf_defaultValues, {\n                ...__classPrivateFieldGet(this, _Conf_defaultValues, \"f\"),\n                ...options.defaults\n            }, \"f\");\n        }\n        if (options.serialize) {\n            this._serialize = options.serialize;\n        }\n        if (options.deserialize) {\n            this._deserialize = options.deserialize;\n        }\n        this.events = new events_1.EventEmitter();\n        __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, \"f\");\n        const fileExtension = options.fileExtension ? `.${options.fileExtension}` : '';\n        this.path = path.resolve(options.cwd, `${(_a = options.configName) !== null && _a !== void 0 ? _a : 'config'}${fileExtension}`);\n        const fileStore = this.store;\n        const store = Object.assign(createPlainObject(), options.defaults, fileStore);\n        this._validate(store);\n        try {\n            assert.deepEqual(fileStore, store);\n        }\n        catch (_b) {\n            this.store = store;\n        }\n        if (options.watch) {\n            this._watch();\n        }\n        if (options.migrations) {\n            if (!options.projectVersion) {\n                options.projectVersion = getPackageData().version;\n            }\n            if (!options.projectVersion) {\n                throw new Error('Project version could not be inferred. Please specify the `projectVersion` option.');\n            }\n            this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);\n        }\n    }\n    get(key, defaultValue) {\n        if (__classPrivateFieldGet(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n            return this._get(key, defaultValue);\n        }\n        const { store } = this;\n        return key in store ? store[key] : defaultValue;\n    }\n    set(key, value) {\n        if (typeof key !== 'string' && typeof key !== 'object') {\n            throw new TypeError(`Expected \\`key\\` to be of type \\`string\\` or \\`object\\`, got ${typeof key}`);\n        }\n        if (typeof key !== 'object' && value === undefined) {\n            throw new TypeError('Use `delete()` to clear values');\n        }\n        if (this._containsReservedKey(key)) {\n            throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);\n        }\n        const { store } = this;\n        const set = (key, value) => {\n            checkValueType(key, value);\n            if (__classPrivateFieldGet(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n                dotProp.set(store, key, value);\n            }\n            else {\n                store[key] = value;\n            }\n        };\n        if (typeof key === 'object') {\n            const object = key;\n            for (const [key, value] of Object.entries(object)) {\n                set(key, value);\n            }\n        }\n        else {\n            set(key, value);\n        }\n        this.store = store;\n    }\n    /**\n    Check if an item exists.\n\n    @param key - The key of the item to check.\n    */\n    has(key) {\n        if (__classPrivateFieldGet(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n            return dotProp.has(this.store, key);\n        }\n        return key in this.store;\n    }\n    /**\n    Reset items to their default values, as defined by the `defaults` or `schema` option.\n\n    @see `clear()` to reset all items.\n\n    @param keys - The keys of the items to reset.\n    */\n    reset(...keys) {\n        for (const key of keys) {\n            if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, \"f\")[key])) {\n                this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, \"f\")[key]);\n            }\n        }\n    }\n    /**\n    Delete an item.\n\n    @param key - The key of the item to delete.\n    */\n    delete(key) {\n        const { store } = this;\n        if (__classPrivateFieldGet(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n            dotProp.delete(store, key);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete store[key];\n        }\n        this.store = store;\n    }\n    /**\n    Delete all items.\n\n    This resets known items to their default values, if defined by the `defaults` or `schema` option.\n    */\n    clear() {\n        this.store = createPlainObject();\n        for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, \"f\"))) {\n            this.reset(key);\n        }\n    }\n    /**\n    Watches the given `key`, calling `callback` on any changes.\n\n    @param key - The key wo watch.\n    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n    @returns A function, that when called, will unsubscribe.\n    */\n    onDidChange(key, callback) {\n        if (typeof key !== 'string') {\n            throw new TypeError(`Expected \\`key\\` to be of type \\`string\\`, got ${typeof key}`);\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n        }\n        return this._handleChange(() => this.get(key), callback);\n    }\n    /**\n    Watches the whole config object, calling `callback` on any changes.\n\n    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n    @returns A function, that when called, will unsubscribe.\n    */\n    onDidAnyChange(callback) {\n        if (typeof callback !== 'function') {\n            throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n        }\n        return this._handleChange(() => this.store, callback);\n    }\n    get size() {\n        return Object.keys(this.store).length;\n    }\n    get store() {\n        try {\n            const data = fs.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, \"f\") ? null : 'utf8');\n            const dataString = this._encryptData(data);\n            const deserializedData = this._deserialize(dataString);\n            this._validate(deserializedData);\n            return Object.assign(createPlainObject(), deserializedData);\n        }\n        catch (error) {\n            if ((error === null || error === void 0 ? void 0 : error.code) === 'ENOENT') {\n                this._ensureDirectory();\n                return createPlainObject();\n            }\n            if (__classPrivateFieldGet(this, _Conf_options, \"f\").clearInvalidConfig && error.name === 'SyntaxError') {\n                return createPlainObject();\n            }\n            throw error;\n        }\n    }\n    set store(value) {\n        this._ensureDirectory();\n        this._validate(value);\n        this._write(value);\n        this.events.emit('change');\n    }\n    *[(_Conf_validator = new WeakMap(), _Conf_encryptionKey = new WeakMap(), _Conf_options = new WeakMap(), _Conf_defaultValues = new WeakMap(), Symbol.iterator)]() {\n        for (const [key, value] of Object.entries(this.store)) {\n            yield [key, value];\n        }\n    }\n    _encryptData(data) {\n        if (!__classPrivateFieldGet(this, _Conf_encryptionKey, \"f\")) {\n            return data.toString();\n        }\n        try {\n            // Check if an initialization vector has been used to encrypt the data\n            if (__classPrivateFieldGet(this, _Conf_encryptionKey, \"f\")) {\n                try {\n                    if (data.slice(16, 17).toString() === ':') {\n                        const initializationVector = data.slice(0, 16);\n                        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, \"f\"), initializationVector.toString(), 10000, 32, 'sha512');\n                        const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);\n                        data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString('utf8');\n                    }\n                    else {\n                        // TODO: Remove this in the next major version.\n                        const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, \"f\"));\n                        data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString('utf8');\n                    }\n                }\n                catch (_a) { }\n            }\n        }\n        catch (_b) { }\n        return data.toString();\n    }\n    _handleChange(getter, callback) {\n        let currentValue = getter();\n        const onChange = () => {\n            const oldValue = currentValue;\n            const newValue = getter();\n            if ((0, util_1.isDeepStrictEqual)(newValue, oldValue)) {\n                return;\n            }\n            currentValue = newValue;\n            callback.call(this, newValue, oldValue);\n        };\n        this.events.on('change', onChange);\n        return () => this.events.removeListener('change', onChange);\n    }\n    _validate(data) {\n        if (!__classPrivateFieldGet(this, _Conf_validator, \"f\")) {\n            return;\n        }\n        const valid = __classPrivateFieldGet(this, _Conf_validator, \"f\").call(this, data);\n        if (valid || !__classPrivateFieldGet(this, _Conf_validator, \"f\").errors) {\n            return;\n        }\n        const errors = __classPrivateFieldGet(this, _Conf_validator, \"f\").errors\n            .map(({ instancePath, message = '' }) => `\\`${instancePath.slice(1)}\\` ${message}`);\n        throw new Error('Config schema violation: ' + errors.join('; '));\n    }\n    _ensureDirectory() {\n        // Ensure the directory exists as it could have been deleted in the meantime.\n        fs.mkdirSync(path.dirname(this.path), { recursive: true });\n    }\n    _write(value) {\n        let data = this._serialize(value);\n        if (__classPrivateFieldGet(this, _Conf_encryptionKey, \"f\")) {\n            const initializationVector = crypto.randomBytes(16);\n            const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, \"f\"), initializationVector.toString(), 10000, 32, 'sha512');\n            const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);\n            data = Buffer.concat([initializationVector, Buffer.from(':'), cipher.update(Buffer.from(data)), cipher.final()]);\n        }\n        // Temporary workaround for Conf being packaged in a Ubuntu Snap app.\n        // See https://github.com/sindresorhus/conf/pull/82\n        if (process.env.SNAP) {\n            fs.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, \"f\").configFileMode });\n        }\n        else {\n            try {\n                atomically.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, \"f\").configFileMode });\n            }\n            catch (error) {\n                // Fix for https://github.com/sindresorhus/electron-store/issues/106\n                // Sometimes on Windows, we will get an EXDEV error when atomic writing\n                // (even though to the same directory), so we fall back to non atomic write\n                if ((error === null || error === void 0 ? void 0 : error.code) === 'EXDEV') {\n                    fs.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, \"f\").configFileMode });\n                    return;\n                }\n                throw error;\n            }\n        }\n    }\n    _watch() {\n        this._ensureDirectory();\n        if (!fs.existsSync(this.path)) {\n            this._write(createPlainObject());\n        }\n        if (process.platform === 'win32') {\n            fs.watch(this.path, { persistent: false }, debounceFn(() => {\n                // On Linux and Windows, writing to the config file emits a `rename` event, so we skip checking the event type.\n                this.events.emit('change');\n            }, { wait: 100 }));\n        }\n        else {\n            fs.watchFile(this.path, { persistent: false }, debounceFn(() => {\n                this.events.emit('change');\n            }, { wait: 5000 }));\n        }\n    }\n    _migrate(migrations, versionToMigrate, beforeEachMigration) {\n        let previousMigratedVersion = this._get(MIGRATION_KEY, '0.0.0');\n        const newerVersions = Object.keys(migrations)\n            .filter(candidateVersion => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));\n        let storeBackup = { ...this.store };\n        for (const version of newerVersions) {\n            try {\n                if (beforeEachMigration) {\n                    beforeEachMigration(this, {\n                        fromVersion: previousMigratedVersion,\n                        toVersion: version,\n                        finalVersion: versionToMigrate,\n                        versions: newerVersions\n                    });\n                }\n                const migration = migrations[version];\n                migration(this);\n                this._set(MIGRATION_KEY, version);\n                previousMigratedVersion = version;\n                storeBackup = { ...this.store };\n            }\n            catch (error) {\n                this.store = storeBackup;\n                throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error}`);\n            }\n        }\n        if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver.eq(previousMigratedVersion, versionToMigrate)) {\n            this._set(MIGRATION_KEY, versionToMigrate);\n        }\n    }\n    _containsReservedKey(key) {\n        if (typeof key === 'object') {\n            const firsKey = Object.keys(key)[0];\n            if (firsKey === INTERNAL_KEY) {\n                return true;\n            }\n        }\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (__classPrivateFieldGet(this, _Conf_options, \"f\").accessPropertiesByDotNotation) {\n            if (key.startsWith(`${INTERNAL_KEY}.`)) {\n                return true;\n            }\n            return false;\n        }\n        return false;\n    }\n    _isVersionInRangeFormat(version) {\n        return semver.clean(version) === null;\n    }\n    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {\n        if (this._isVersionInRangeFormat(candidateVersion)) {\n            if (previousMigratedVersion !== '0.0.0' && semver.satisfies(previousMigratedVersion, candidateVersion)) {\n                return false;\n            }\n            return semver.satisfies(versionToMigrate, candidateVersion);\n        }\n        if (semver.lte(candidateVersion, previousMigratedVersion)) {\n            return false;\n        }\n        if (semver.gt(candidateVersion, versionToMigrate)) {\n            return false;\n        }\n        return true;\n    }\n    _get(key, defaultValue) {\n        return dotProp.get(this.store, key, defaultValue);\n    }\n    _set(key, value) {\n        const { store } = this;\n        dotProp.set(store, key, value);\n        this.store = store;\n    }\n}\nexports[\"default\"] = Conf;\n// For CommonJS default export support\nmodule.exports = Conf;\nmodule.exports[\"default\"] = Conf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVU7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLG9EQUFRO0FBQzlCLGlCQUFpQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxpREFBSztBQUMzQixzQkFBc0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN4QyxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEtBQUssZUFBZSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUFBdUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0EsYUFBYSxJQUFJLFdBQVc7QUFDNUI7QUFDQTtBQUNBLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQSxhQUFhLElBQUksWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlKQUF5SixNQUFNO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0EseUJBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VycmUtbGFiLXNpdGUvLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcz9lMTk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9hLCBfYjtcbnZhciBfQ29uZl92YWxpZGF0b3IsIF9Db25mX2VuY3J5cHRpb25LZXksIF9Db25mX29wdGlvbnMsIF9Db25mX2RlZmF1bHRWYWx1ZXM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkb3RQcm9wID0gcmVxdWlyZShcImRvdC1wcm9wXCIpO1xuY29uc3QgcGtnVXAgPSByZXF1aXJlKFwicGtnLXVwXCIpO1xuY29uc3QgZW52UGF0aHMgPSByZXF1aXJlKFwiZW52LXBhdGhzXCIpO1xuY29uc3QgYXRvbWljYWxseSA9IHJlcXVpcmUoXCJhdG9taWNhbGx5XCIpO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgYWp2X2Zvcm1hdHNfMSA9IHJlcXVpcmUoXCJhanYtZm9ybWF0c1wiKTtcbmNvbnN0IGRlYm91bmNlRm4gPSByZXF1aXJlKFwiZGVib3VuY2UtZm5cIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgb25ldGltZSA9IHJlcXVpcmUoXCJvbmV0aW1lXCIpO1xuY29uc3QgZW5jcnlwdGlvbkFsZ29yaXRobSA9ICdhZXMtMjU2LWNiYyc7XG5jb25zdCBjcmVhdGVQbGFpbk9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07XG5jb25zdCBpc0V4aXN0ID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGw7XG59O1xubGV0IHBhcmVudERpciA9ICcnO1xudHJ5IHtcbiAgICAvLyBQcmV2ZW50IGNhY2hpbmcgb2YgdGhpcyBtb2R1bGUgc28gbW9kdWxlLnBhcmVudCBpcyBhbHdheXMgYWNjdXJhdGUuXG4gICAgLy8gTm90ZTogVGhpcyB0cmljayB3b24ndCB3b3JrIHdpdGggRVNNIG9yIGluc2lkZSBhIHdlYndvcmtlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICBkZWxldGUgcmVxdWlyZS5jYWNoZVtfX2ZpbGVuYW1lXTtcbiAgICBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoKF9iID0gKF9hID0gbW9kdWxlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVuYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnLicpO1xufVxuY2F0Y2ggKF9jKSB7IH1cbmNvbnN0IGNoZWNrVmFsdWVUeXBlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBub25Kc29uVHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdzeW1ib2wnLFxuICAgICAgICAnZnVuY3Rpb24nXG4gICAgXSk7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAobm9uSnNvblR5cGVzLmhhcyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTZXR0aW5nIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgIGZvciBrZXkgXFxgJHtrZXl9XFxgIGlzIG5vdCBhbGxvd2VkIGFzIGl0J3Mgbm90IHN1cHBvcnRlZCBieSBKU09OYCk7XG4gICAgfVxufTtcbmNvbnN0IElOVEVSTkFMX0tFWSA9ICdfX2ludGVybmFsX18nO1xuY29uc3QgTUlHUkFUSU9OX0tFWSA9IGAke0lOVEVSTkFMX0tFWX0ubWlncmF0aW9ucy52ZXJzaW9uYDtcbmNsYXNzIENvbmYge1xuICAgIGNvbnN0cnVjdG9yKHBhcnRpYWxPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfQ29uZl92YWxpZGF0b3Iuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2VuY3J5cHRpb25LZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX29wdGlvbnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2RlZmF1bHRWYWx1ZXMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSB2YWx1ZSA9PiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplID0gdmFsdWUgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHVuZGVmaW5lZCwgJ1xcdCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgY29uZmlnTmFtZTogJ2NvbmZpZycsXG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiAnanNvbicsXG4gICAgICAgICAgICBwcm9qZWN0U3VmZml4OiAnbm9kZWpzJyxcbiAgICAgICAgICAgIGNsZWFySW52YWxpZENvbmZpZzogZmFsc2UsXG4gICAgICAgICAgICBhY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ0ZpbGVNb2RlOiAwbzY2NixcbiAgICAgICAgICAgIC4uLnBhcnRpYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFBhY2thZ2VEYXRhID0gb25ldGltZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBrZ1VwLnN5bmMoeyBjd2Q6IHBhcmVudERpciB9KTtcbiAgICAgICAgICAgIC8vIENhbid0IHVzZSBgcmVxdWlyZWAgYmVjYXVzZSBvZiBXZWJwYWNrIGJlaW5nIGFubm95aW5nOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTk2XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlRGF0YSA9IHBhY2thZ2VQYXRoICYmIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrYWdlRGF0YSAhPT0gbnVsbCAmJiBwYWNrYWdlRGF0YSAhPT0gdm9pZCAwID8gcGFja2FnZURhdGEgOiB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5jd2QpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdE5hbWUgPSBnZXRQYWNrYWdlRGF0YSgpLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgbmFtZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdE5hbWVgIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY3dkID0gZW52UGF0aHMob3B0aW9ucy5wcm9qZWN0TmFtZSwgeyBzdWZmaXg6IG9wdGlvbnMucHJvamVjdFN1ZmZpeCB9KS5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBvcHRpb25zLCBcImZcIik7XG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHNjaGVtYWAgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWp2ID0gbmV3IGFqdl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGFsbEVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoMCwgYWp2X2Zvcm1hdHNfMS5kZWZhdWx0KShhanYpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG9wdGlvbnMuc2NoZW1hXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl92YWxpZGF0b3IsIGFqdi5jb21waWxlKHNjaGVtYSksIFwiZlwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldID0gdmFsdWUuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywge1xuICAgICAgICAgICAgICAgIC4uLl9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuZGVmYXVsdHNcbiAgICAgICAgICAgIH0sIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zZXJpYWxpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcmlhbGl6ZSA9IG9wdGlvbnMuc2VyaWFsaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlc2VyaWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXNlcmlhbGl6ZSA9IG9wdGlvbnMuZGVzZXJpYWxpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgb3B0aW9ucy5lbmNyeXB0aW9uS2V5LCBcImZcIik7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBvcHRpb25zLmZpbGVFeHRlbnNpb24gPyBgLiR7b3B0aW9ucy5maWxlRXh0ZW5zaW9ufWAgOiAnJztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBgJHsoX2EgPSBvcHRpb25zLmNvbmZpZ05hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdjb25maWcnfSR7ZmlsZUV4dGVuc2lvbn1gKTtcbiAgICAgICAgY29uc3QgZmlsZVN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBPYmplY3QuYXNzaWduKGNyZWF0ZVBsYWluT2JqZWN0KCksIG9wdGlvbnMuZGVmYXVsdHMsIGZpbGVTdG9yZSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKHN0b3JlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoZmlsZVN0b3JlLCBzdG9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMud2F0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9qZWN0VmVyc2lvbiA9IGdldFBhY2thZ2VEYXRhKCkudmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdCB2ZXJzaW9uIGNvdWxkIG5vdCBiZSBpbmZlcnJlZC4gUGxlYXNlIHNwZWNpZnkgdGhlIGBwcm9qZWN0VmVyc2lvbmAgb3B0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWlncmF0ZShvcHRpb25zLm1pZ3JhdGlvbnMsIG9wdGlvbnMucHJvamVjdFZlcnNpb24sIG9wdGlvbnMuYmVmb3JlRWFjaE1pZ3JhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGtleSBpbiBzdG9yZSA/IHN0b3JlW2tleV0gOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Yga2V5ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxga2V5XFxgIHRvIGJlIG9mIHR5cGUgXFxgc3RyaW5nXFxgIG9yIFxcYG9iamVjdFxcYCwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNlIGBkZWxldGUoKWAgdG8gY2xlYXIgdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5zUmVzZXJ2ZWRLZXkoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGxlYXNlIGRvbid0IHVzZSB0aGUgJHtJTlRFUk5BTF9LRVl9IGtleSwgYXMgaXQncyB1c2VkIHRvIG1hbmFnZSB0aGlzIG1vZHVsZSBpbnRlcm5hbCBvcGVyYXRpb25zLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNldCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjaGVja1ZhbHVlVHlwZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGRvdFByb3Auc2V0KHN0b3JlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSBrZXk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgaWYgYW4gaXRlbSBleGlzdHMuXG5cbiAgICBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byBjaGVjay5cbiAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZG90UHJvcC5oYXModGhpcy5zdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5IGluIHRoaXMuc3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBhcyBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cblxuICAgIEBzZWUgYGNsZWFyKClgIHRvIHJlc2V0IGFsbCBpdGVtcy5cblxuICAgIEBwYXJhbSBrZXlzIC0gVGhlIGtleXMgb2YgdGhlIGl0ZW1zIHRvIHJlc2V0LlxuICAgICovXG4gICAgcmVzZXQoLi4ua2V5cykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBpZiAoaXNFeGlzdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIilba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFuIGl0ZW0uXG5cbiAgICBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byBkZWxldGUuXG4gICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgZG90UHJvcC5kZWxldGUoc3RvcmUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSBhbGwgaXRlbXMuXG5cbiAgICBUaGlzIHJlc2V0cyBrbm93biBpdGVtcyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcywgaWYgZGVmaW5lZCBieSB0aGUgYGRlZmF1bHRzYCBvciBgc2NoZW1hYCBvcHRpb24uXG4gICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFdhdGNoZXMgdGhlIGdpdmVuIGBrZXlgLCBjYWxsaW5nIGBjYWxsYmFja2Agb24gYW55IGNoYW5nZXMuXG5cbiAgICBAcGFyYW0ga2V5IC0gVGhlIGtleSB3byB3YXRjaC5cbiAgICBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGFueSBjaGFuZ2VzLiBXaGVuIGEgYGtleWAgaXMgZmlyc3Qgc2V0IGBvbGRWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYCwgYW5kIHdoZW4gYSBrZXkgaXMgZGVsZXRlZCBgbmV3VmFsdWVgIHdpbGwgYmUgYHVuZGVmaW5lZGAuXG4gICAgQHJldHVybnMgQSBmdW5jdGlvbiwgdGhhdCB3aGVuIGNhbGxlZCwgd2lsbCB1bnN1YnNjcmliZS5cbiAgICAqL1xuICAgIG9uRGlkQ2hhbmdlKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBrZXlcXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAsIGdvdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY2FsbGJhY2tcXGAgdG8gYmUgb2YgdHlwZSBcXGBmdW5jdGlvblxcYCwgZ290ICR7dHlwZW9mIGNhbGxiYWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDaGFuZ2UoKCkgPT4gdGhpcy5nZXQoa2V5KSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICBXYXRjaGVzIHRoZSB3aG9sZSBjb25maWcgb2JqZWN0LCBjYWxsaW5nIGBjYWxsYmFja2Agb24gYW55IGNoYW5nZXMuXG5cbiAgICBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGFueSBjaGFuZ2VzLiBXaGVuIGEgYGtleWAgaXMgZmlyc3Qgc2V0IGBvbGRWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYCwgYW5kIHdoZW4gYSBrZXkgaXMgZGVsZXRlZCBgbmV3VmFsdWVgIHdpbGwgYmUgYHVuZGVmaW5lZGAuXG4gICAgQHJldHVybnMgQSBmdW5jdGlvbiwgdGhhdCB3aGVuIGNhbGxlZCwgd2lsbCB1bnN1YnNjcmliZS5cbiAgICAqL1xuICAgIG9uRGlkQW55Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGNhbGxiYWNrXFxgIHRvIGJlIG9mIHR5cGUgXFxgZnVuY3Rpb25cXGAsIGdvdCAke3R5cGVvZiBjYWxsYmFja31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQ2hhbmdlKCgpID0+IHRoaXMuc3RvcmUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JlKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBzdG9yZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmModGhpcy5wYXRoLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSA/IG51bGwgOiAndXRmOCcpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVN0cmluZyA9IHRoaXMuX2VuY3J5cHREYXRhKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRGF0YSA9IHRoaXMuX2Rlc2VyaWFsaXplKGRhdGFTdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGUoZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjcmVhdGVQbGFpbk9iamVjdCgpLCBkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZURpcmVjdG9yeSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQbGFpbk9iamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmNsZWFySW52YWxpZENvbmZpZyAmJiBlcnJvci5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgc3RvcmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fd3JpdGUodmFsdWUpO1xuICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICB9XG4gICAgKlsoX0NvbmZfdmFsaWRhdG9yID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfZW5jcnlwdGlvbktleSA9IG5ldyBXZWFrTWFwKCksIF9Db25mX29wdGlvbnMgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9kZWZhdWx0VmFsdWVzID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc3RvcmUpKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuY3J5cHREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIFwiZlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gaW5pdGlhbGl6YXRpb24gdmVjdG9yIGhhcyBiZWVuIHVzZWQgdG8gZW5jcnlwdCB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc2xpY2UoMTYsIDE3KS50b1N0cmluZygpID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gZGF0YS5zbGljZSgwLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IGNyeXB0by5wYmtkZjJTeW5jKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpLCBpbml0aWFsaXphdGlvblZlY3Rvci50b1N0cmluZygpLCAxMDAwMCwgMzIsICdzaGE1MTInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoZW5jcnlwdGlvbkFsZ29yaXRobSwgcGFzc3dvcmQsIGluaXRpYWxpemF0aW9uVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkZWNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YS5zbGljZSgxNykpKSwgZGVjaXBoZXIuZmluYWwoKV0pLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXIoZW5jcnlwdGlvbkFsZ29yaXRobSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSksIGRlY2lwaGVyLmZpbmFsKCldKS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7IH1cbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgX2hhbmRsZUNoYW5nZShnZXR0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5pc0RlZXBTdHJpY3RFcXVhbCkobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICB9XG4gICAgX3ZhbGlkYXRlKGRhdGEpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIGlmICh2YWxpZCB8fCAhX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl92YWxpZGF0b3IsIFwiZlwiKS5lcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmVycm9yc1xuICAgICAgICAgICAgLm1hcCgoeyBpbnN0YW5jZVBhdGgsIG1lc3NhZ2UgPSAnJyB9KSA9PiBgXFxgJHtpbnN0YW5jZVBhdGguc2xpY2UoMSl9XFxgICR7bWVzc2FnZX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWcgc2NoZW1hIHZpb2xhdGlvbjogJyArIGVycm9ycy5qb2luKCc7ICcpKTtcbiAgICB9XG4gICAgX2Vuc3VyZURpcmVjdG9yeSgpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBkaXJlY3RvcnkgZXhpc3RzIGFzIGl0IGNvdWxkIGhhdmUgYmVlbiBkZWxldGVkIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZSh0aGlzLnBhdGgpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgX3dyaXRlKHZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblZlY3RvciA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG4gICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IGNyeXB0by5wYmtkZjJTeW5jKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpLCBpbml0aWFsaXphdGlvblZlY3Rvci50b1N0cmluZygpLCAxMDAwMCwgMzIsICdzaGE1MTInKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2luaXRpYWxpemF0aW9uVmVjdG9yLCBCdWZmZXIuZnJvbSgnOicpLCBjaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKSwgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCBmb3IgQ29uZiBiZWluZyBwYWNrYWdlZCBpbiBhIFVidW50dSBTbmFwIGFwcC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvY29uZi9wdWxsLzgyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5TTkFQKSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSwgeyBtb2RlOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5jb25maWdGaWxlTW9kZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXRvbWljYWxseS53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSwgeyBtb2RlOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5jb25maWdGaWxlTW9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9lbGVjdHJvbi1zdG9yZS9pc3N1ZXMvMTA2XG4gICAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIG9uIFdpbmRvd3MsIHdlIHdpbGwgZ2V0IGFuIEVYREVWIGVycm9yIHdoZW4gYXRvbWljIHdyaXRpbmdcbiAgICAgICAgICAgICAgICAvLyAoZXZlbiB0aG91Z2ggdG8gdGhlIHNhbWUgZGlyZWN0b3J5KSwgc28gd2UgZmFsbCBiYWNrIHRvIG5vbiBhdG9taWMgd3JpdGVcbiAgICAgICAgICAgICAgICBpZiAoKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5jb2RlKSA9PT0gJ0VYREVWJykge1xuICAgICAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSwgeyBtb2RlOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5jb25maWdGaWxlTW9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfd2F0Y2goKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZURpcmVjdG9yeSgpO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmModGhpcy5wYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGUoY3JlYXRlUGxhaW5PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIGZzLndhdGNoKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBPbiBMaW51eCBhbmQgV2luZG93cywgd3JpdGluZyB0byB0aGUgY29uZmlnIGZpbGUgZW1pdHMgYSBgcmVuYW1lYCBldmVudCwgc28gd2Ugc2tpcCBjaGVja2luZyB0aGUgZXZlbnQgdHlwZS5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0sIHsgd2FpdDogMTAwIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZzLndhdGNoRmlsZSh0aGlzLnBhdGgsIHsgcGVyc2lzdGVudDogZmFsc2UgfSwgZGVib3VuY2VGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgICAgICB9LCB7IHdhaXQ6IDUwMDAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9taWdyYXRlKG1pZ3JhdGlvbnMsIHZlcnNpb25Ub01pZ3JhdGUsIGJlZm9yZUVhY2hNaWdyYXRpb24pIHtcbiAgICAgICAgbGV0IHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uID0gdGhpcy5fZ2V0KE1JR1JBVElPTl9LRVksICcwLjAuMCcpO1xuICAgICAgICBjb25zdCBuZXdlclZlcnNpb25zID0gT2JqZWN0LmtleXMobWlncmF0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIoY2FuZGlkYXRlVmVyc2lvbiA9PiB0aGlzLl9zaG91bGRQZXJmb3JtTWlncmF0aW9uKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSk7XG4gICAgICAgIGxldCBzdG9yZUJhY2t1cCA9IHsgLi4udGhpcy5zdG9yZSB9O1xuICAgICAgICBmb3IgKGNvbnN0IHZlcnNpb24gb2YgbmV3ZXJWZXJzaW9ucykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlRWFjaE1pZ3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoTWlncmF0aW9uKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21WZXJzaW9uOiBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmVyc2lvbjogdmVyc2lvblRvTWlncmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb25zOiBuZXdlclZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtaWdyYXRpb24gPSBtaWdyYXRpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgICAgIG1pZ3JhdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXQoTUlHUkFUSU9OX0tFWSwgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIHN0b3JlQmFja3VwID0geyAuLi50aGlzLnN0b3JlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmVCYWNrdXA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgdGhlIG1pZ3JhdGlvbiEgQ2hhbmdlcyBhcHBsaWVkIHRvIHRoZSBzdG9yZSB1bnRpbCB0aGlzIGZhaWxlZCBtaWdyYXRpb24gd2lsbCBiZSByZXN0b3JlZC4gJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNWZXJzaW9uSW5SYW5nZUZvcm1hdChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbikgfHwgIXNlbXZlci5lcShwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldChNSUdSQVRJT05fS0VZLCB2ZXJzaW9uVG9NaWdyYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29udGFpbnNSZXNlcnZlZEtleShrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzS2V5ID0gT2JqZWN0LmtleXMoa2V5KVswXTtcbiAgICAgICAgICAgIGlmIChmaXJzS2V5ID09PSBJTlRFUk5BTF9LRVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChgJHtJTlRFUk5BTF9LRVl9LmApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfaXNWZXJzaW9uSW5SYW5nZUZvcm1hdCh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBzZW12ZXIuY2xlYW4odmVyc2lvbikgPT09IG51bGw7XG4gICAgfVxuICAgIF9zaG91bGRQZXJmb3JtTWlncmF0aW9uKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KGNhbmRpZGF0ZVZlcnNpb24pKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNNaWdyYXRlZFZlcnNpb24gIT09ICcwLjAuMCcgJiYgc2VtdmVyLnNhdGlzZmllcyhwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiwgY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VtdmVyLnNhdGlzZmllcyh2ZXJzaW9uVG9NaWdyYXRlLCBjYW5kaWRhdGVWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VtdmVyLmx0ZShjYW5kaWRhdGVWZXJzaW9uLCBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VtdmVyLmd0KGNhbmRpZGF0ZVZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9nZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRvdFByb3AuZ2V0KHRoaXMuc3RvcmUsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgX3NldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIGRvdFByb3Auc2V0KHN0b3JlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbmY7XG4vLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxubW9kdWxlLmV4cG9ydHMgPSBDb25mO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbmY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/conf/dist/source/index.js\n");

/***/ })

};
;