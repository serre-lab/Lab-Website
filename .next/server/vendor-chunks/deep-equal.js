"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/deep-equal";
exports.ids = ["vendor-chunks/deep-equal"];
exports.modules = {

/***/ "(ssr)/./node_modules/deep-equal/index.js":
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar assign = __webpack_require__(/*! object.assign */ \"(ssr)/./node_modules/object.assign/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"(ssr)/./node_modules/call-bind/callBound.js\");\nvar flags = __webpack_require__(/*! regexp.prototype.flags */ \"(ssr)/./node_modules/regexp.prototype.flags/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"(ssr)/./node_modules/get-intrinsic/index.js\");\nvar getIterator = __webpack_require__(/*! es-get-iterator */ \"(ssr)/./node_modules/es-get-iterator/node.js\");\nvar getSideChannel = __webpack_require__(/*! side-channel */ \"(ssr)/./node_modules/side-channel/index.js\");\nvar is = __webpack_require__(/*! object-is */ \"(ssr)/./node_modules/object-is/index.js\");\nvar isArguments = __webpack_require__(/*! is-arguments */ \"(ssr)/./node_modules/is-arguments/index.js\");\nvar isArray = __webpack_require__(/*! isarray */ \"(ssr)/./node_modules/isarray/index.js\");\nvar isArrayBuffer = __webpack_require__(/*! is-array-buffer */ \"(ssr)/./node_modules/is-array-buffer/index.js\");\nvar isDate = __webpack_require__(/*! is-date-object */ \"(ssr)/./node_modules/is-date-object/index.js\");\nvar isRegex = __webpack_require__(/*! is-regex */ \"(ssr)/./node_modules/is-regex/index.js\");\nvar isSharedArrayBuffer = __webpack_require__(/*! is-shared-array-buffer */ \"(ssr)/./node_modules/is-shared-array-buffer/index.js\");\nvar objectKeys = __webpack_require__(/*! object-keys */ \"(ssr)/./node_modules/object-keys/index.js\");\nvar whichBoxedPrimitive = __webpack_require__(/*! which-boxed-primitive */ \"(ssr)/./node_modules/which-boxed-primitive/index.js\");\nvar whichCollection = __webpack_require__(/*! which-collection */ \"(ssr)/./node_modules/which-collection/index.js\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"(ssr)/./node_modules/which-typed-array/index.js\");\nvar byteLength = __webpack_require__(/*! array-buffer-byte-length */ \"(ssr)/./node_modules/array-buffer-byte-length/index.js\");\n\nvar sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);\n\nvar $getTime = callBound('Date.prototype.getTime');\nvar gPO = Object.getPrototypeOf;\nvar $objToString = callBound('Object.prototype.toString');\n\nvar $Set = GetIntrinsic('%Set%', true);\nvar $mapHas = callBound('Map.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSize = callBound('Map.prototype.size', true);\nvar $setAdd = callBound('Set.prototype.add', true);\nvar $setDelete = callBound('Set.prototype.delete', true);\nvar $setHas = callBound('Set.prototype.has', true);\nvar $setSize = callBound('Set.prototype.size', true);\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414\nfunction setHasEqualElement(set, val1, opts, channel) {\n  var i = getIterator(set);\n  var result;\n  while ((result = i.next()) && !result.done) {\n    if (internalDeepEqual(val1, result.value, opts, channel)) { // eslint-disable-line no-use-before-define\n      // Remove the matching element to make sure we do not check that again.\n      $setDelete(set, result.value);\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439\nfunction findLooseMatchingPrimitives(prim) {\n  if (typeof prim === 'undefined') {\n    return null;\n  }\n  if (typeof prim === 'object') { // Only pass in null as object!\n    return void 0;\n  }\n  if (typeof prim === 'symbol') {\n    return false;\n  }\n  if (typeof prim === 'string' || typeof prim === 'number') {\n    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.\n    return +prim === +prim; // eslint-disable-line no-implicit-coercion\n  }\n  return true;\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460\nfunction mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n  var curB = $mapGet(b, altValue);\n  var looseOpts = assign({}, opts, { strict: false });\n  if (\n    (typeof curB === 'undefined' && !$mapHas(b, altValue))\n    // eslint-disable-next-line no-use-before-define\n    || !internalDeepEqual(item, curB, looseOpts, channel)\n  ) {\n    return false;\n  }\n  // eslint-disable-next-line no-use-before-define\n  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n\n  return $setHas(b, altValue) && !$setHas(a, altValue);\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533\nfunction mapHasEqualEntry(set, map, key1, item1, opts, channel) {\n  var i = getIterator(set);\n  var result;\n  var key2;\n  while ((result = i.next()) && !result.done) {\n    key2 = result.value;\n    if (\n      // eslint-disable-next-line no-use-before-define\n      internalDeepEqual(key1, key2, opts, channel)\n      // eslint-disable-next-line no-use-before-define\n      && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)\n    ) {\n      $setDelete(set, key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction internalDeepEqual(actual, expected, options, channel) {\n  var opts = options || {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (opts.strict ? is(actual, expected) : actual === expected) {\n    return true;\n  }\n\n  var actualBoxed = whichBoxedPrimitive(actual);\n  var expectedBoxed = whichBoxedPrimitive(expected);\n  if (actualBoxed !== expectedBoxed) {\n    return false;\n  }\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.\n  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {\n    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq\n  }\n\n  /*\n   * 7.4. For all other Object pairs, including Array objects, equivalence is\n   * determined by having the same number of owned properties (as verified\n   * with Object.prototype.hasOwnProperty.call), the same set of keys\n   * (although not necessarily the same order), equivalent values for every\n   * corresponding key, and an identical 'prototype' property. Note: this\n   * accounts for both named and indexed properties on Arrays.\n   */\n  // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration\n\n  var hasActual = channel.has(actual);\n  var hasExpected = channel.has(expected);\n  var sentinel;\n  if (hasActual && hasExpected) {\n    if (channel.get(actual) === channel.get(expected)) {\n      return true;\n    }\n  } else {\n    sentinel = {};\n  }\n  if (!hasActual) { channel.set(actual, sentinel); }\n  if (!hasExpected) { channel.set(expected, sentinel); }\n\n  // eslint-disable-next-line no-use-before-define\n  return objEquiv(actual, expected, opts, channel);\n}\n\nfunction isBuffer(x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {\n    return false;\n  }\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') {\n    return false;\n  }\n\n  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));\n}\n\nfunction setEquiv(a, b, opts, channel) {\n  if ($setSize(a) !== $setSize(b)) {\n    return false;\n  }\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n  while ((resultA = iA.next()) && !resultA.done) {\n    if (resultA.value && typeof resultA.value === 'object') {\n      if (!set) { set = new $Set(); }\n      $setAdd(set, resultA.value);\n    } else if (!$setHas(b, resultA.value)) {\n      if (opts.strict) { return false; }\n      if (!setMightHaveLoosePrim(a, b, resultA.value)) {\n        return false;\n      }\n      if (!set) { set = new $Set(); }\n      $setAdd(set, resultA.value);\n    }\n  }\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      // We have to check if a primitive value is already matching and only if it's not, go hunting for it.\n      if (resultB.value && typeof resultB.value === 'object') {\n        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {\n          return false;\n        }\n      } else if (\n        !opts.strict\n        && !$setHas(a, resultB.value)\n        && !setHasEqualElement(set, resultB.value, opts.strict, channel)\n      ) {\n        return false;\n      }\n    }\n    return $setSize(set) === 0;\n  }\n  return true;\n}\n\nfunction mapEquiv(a, b, opts, channel) {\n  if ($mapSize(a) !== $mapSize(b)) {\n    return false;\n  }\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n  var key;\n  var item1;\n  var item2;\n  while ((resultA = iA.next()) && !resultA.done) {\n    key = resultA.value[0];\n    item1 = resultA.value[1];\n    if (key && typeof key === 'object') {\n      if (!set) { set = new $Set(); }\n      $setAdd(set, key);\n    } else {\n      item2 = $mapGet(b, key);\n      if ((typeof item2 === 'undefined' && !$mapHas(b, key)) || !internalDeepEqual(item1, item2, opts, channel)) {\n        if (opts.strict) {\n          return false;\n        }\n        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {\n          return false;\n        }\n        if (!set) { set = new $Set(); }\n        $setAdd(set, key);\n      }\n    }\n  }\n\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      key = resultB.value[0];\n      item2 = resultB.value[1];\n      if (key && typeof key === 'object') {\n        if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {\n          return false;\n        }\n      } else if (\n        !opts.strict\n        && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel))\n        && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)\n      ) {\n        return false;\n      }\n    }\n    return $setSize(set) === 0;\n  }\n  return true;\n}\n\nfunction objEquiv(a, b, opts, channel) {\n  /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5], max-lines: [2, 400] */\n  var i, key;\n\n  if (typeof a !== typeof b) { return false; }\n  if (a == null || b == null) { return false; }\n\n  if ($objToString(a) !== $objToString(b)) { return false; }\n\n  if (isArguments(a) !== isArguments(b)) { return false; }\n\n  var aIsArray = isArray(a);\n  var bIsArray = isArray(b);\n  if (aIsArray !== bIsArray) { return false; }\n\n  // TODO: replace when a cross-realm brand check is available\n  var aIsError = a instanceof Error;\n  var bIsError = b instanceof Error;\n  if (aIsError !== bIsError) { return false; }\n  if (aIsError || bIsError) {\n    if (a.name !== b.name || a.message !== b.message) { return false; }\n  }\n\n  var aIsRegex = isRegex(a);\n  var bIsRegex = isRegex(b);\n  if (aIsRegex !== bIsRegex) { return false; }\n  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {\n    return false;\n  }\n\n  var aIsDate = isDate(a);\n  var bIsDate = isDate(b);\n  if (aIsDate !== bIsDate) { return false; }\n  if (aIsDate || bIsDate) { // && would work too, because both are true or both false here\n    if ($getTime(a) !== $getTime(b)) { return false; }\n  }\n  if (opts.strict && gPO && gPO(a) !== gPO(b)) { return false; }\n\n  var aWhich = whichTypedArray(a);\n  var bWhich = whichTypedArray(b);\n  if (aWhich !== bWhich) {\n    return false;\n  }\n  if (aWhich || bWhich) { // && would work too, because both are true or both false here\n    if (a.length !== b.length) { return false; }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) { return false; }\n    }\n    return true;\n  }\n\n  var aIsBuffer = isBuffer(a);\n  var bIsBuffer = isBuffer(b);\n  if (aIsBuffer !== bIsBuffer) { return false; }\n  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here\n    if (a.length !== b.length) { return false; }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) { return false; }\n    }\n    return true;\n  }\n\n  var aIsArrayBuffer = isArrayBuffer(a);\n  var bIsArrayBuffer = isArrayBuffer(b);\n  if (aIsArrayBuffer !== bIsArrayBuffer) { return false; }\n  if (aIsArrayBuffer || bIsArrayBuffer) { // && would work too, because both are true or both false here\n    if (byteLength(a) !== byteLength(b)) { return false; }\n    return typeof Uint8Array === 'function' && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);\n  }\n\n  var aIsSAB = isSharedArrayBuffer(a);\n  var bIsSAB = isSharedArrayBuffer(b);\n  if (aIsSAB !== bIsSAB) { return false; }\n  if (aIsSAB || bIsSAB) { // && would work too, because both are true or both false here\n    if (sabByteLength(a) !== sabByteLength(b)) { return false; }\n    return typeof Uint8Array === 'function' && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);\n  }\n\n  if (typeof a !== typeof b) { return false; }\n\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  // having the same number of owned properties (keys incorporates hasOwnProperty)\n  if (ka.length !== kb.length) { return false; }\n\n  // the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  // ~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) { return false; } // eslint-disable-line eqeqeq\n  }\n\n  // equivalent values for every corresponding key, and ~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!internalDeepEqual(a[key], b[key], opts, channel)) { return false; }\n  }\n\n  var aCollection = whichCollection(a);\n  var bCollection = whichCollection(b);\n  if (aCollection !== bCollection) {\n    return false;\n  }\n  if (aCollection === 'Set' || bCollection === 'Set') { // aCollection === bCollection\n    return setEquiv(a, b, opts, channel);\n  }\n  if (aCollection === 'Map') { // aCollection === bCollection\n    return mapEquiv(a, b, opts, channel);\n  }\n\n  return true;\n}\n\nmodule.exports = function deepEqual(a, b, opts) {\n  return internalDeepEqual(a, b, opts, getSideChannel());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0VBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLFlBQVksbUJBQU8sQ0FBQyxvRkFBd0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsa0VBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMscUVBQWlCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLGdFQUFjO0FBQzNDLFNBQVMsbUJBQU8sQ0FBQywwREFBVztBQUM1QixrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBYztBQUN4QyxjQUFjLG1CQUFPLENBQUMsc0RBQVM7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsc0VBQWlCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDckMsY0FBYyxtQkFBTyxDQUFDLHdEQUFVO0FBQ2hDLDBCQUEwQixtQkFBTyxDQUFDLG9GQUF3QjtBQUMxRCxpQkFBaUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN0QywwQkFBMEIsbUJBQU8sQ0FBQyxrRkFBdUI7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsd0VBQWtCO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLDBFQUFtQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBMEI7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VycmUtbGFiLXNpdGUvLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcz80M2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC5hc3NpZ24nKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgZmxhZ3MgPSByZXF1aXJlKCdyZWdleHAucHJvdG90eXBlLmZsYWdzJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnZXMtZ2V0LWl0ZXJhdG9yJyk7XG52YXIgZ2V0U2lkZUNoYW5uZWwgPSByZXF1aXJlKCdzaWRlLWNoYW5uZWwnKTtcbnZhciBpcyA9IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0FycmF5QnVmZmVyID0gcmVxdWlyZSgnaXMtYXJyYXktYnVmZmVyJyk7XG52YXIgaXNEYXRlID0gcmVxdWlyZSgnaXMtZGF0ZS1vYmplY3QnKTtcbnZhciBpc1JlZ2V4ID0gcmVxdWlyZSgnaXMtcmVnZXgnKTtcbnZhciBpc1NoYXJlZEFycmF5QnVmZmVyID0gcmVxdWlyZSgnaXMtc2hhcmVkLWFycmF5LWJ1ZmZlcicpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIHdoaWNoQm94ZWRQcmltaXRpdmUgPSByZXF1aXJlKCd3aGljaC1ib3hlZC1wcmltaXRpdmUnKTtcbnZhciB3aGljaENvbGxlY3Rpb24gPSByZXF1aXJlKCd3aGljaC1jb2xsZWN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBieXRlTGVuZ3RoID0gcmVxdWlyZSgnYXJyYXktYnVmZmVyLWJ5dGUtbGVuZ3RoJyk7XG5cbnZhciBzYWJCeXRlTGVuZ3RoID0gY2FsbEJvdW5kKCdTaGFyZWRBcnJheUJ1ZmZlci5wcm90b3R5cGUuYnl0ZUxlbmd0aCcsIHRydWUpO1xuXG52YXIgJGdldFRpbWUgPSBjYWxsQm91bmQoJ0RhdGUucHJvdG90eXBlLmdldFRpbWUnKTtcbnZhciBnUE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgJG9ialRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciAkU2V0ID0gR2V0SW50cmluc2ljKCclU2V0JScsIHRydWUpO1xudmFyICRtYXBIYXMgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbnZhciAkbWFwU2l6ZSA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5zaXplJywgdHJ1ZSk7XG52YXIgJHNldEFkZCA9IGNhbGxCb3VuZCgnU2V0LnByb3RvdHlwZS5hZGQnLCB0cnVlKTtcbnZhciAkc2V0RGVsZXRlID0gY2FsbEJvdW5kKCdTZXQucHJvdG90eXBlLmRlbGV0ZScsIHRydWUpO1xudmFyICRzZXRIYXMgPSBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG52YXIgJHNldFNpemUgPSBjYWxsQm91bmQoJ1NldC5wcm90b3R5cGUuc2l6ZScsIHRydWUpO1xuXG4vLyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9icm93c2VyaWZ5L2NvbW1vbmpzLWFzc2VydC9ibG9iL2JiYTgzOGU5YmE5ZTI4ZWRmMzEyN2NlNjk3NDYyNDIwODUwMmY2YmMvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qcyNMNDAxLUw0MTRcbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIG9wdHMsIGNoYW5uZWwpIHtcbiAgdmFyIGkgPSBnZXRJdGVyYXRvcihzZXQpO1xuICB2YXIgcmVzdWx0O1xuICB3aGlsZSAoKHJlc3VsdCA9IGkubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBpZiAoaW50ZXJuYWxEZWVwRXF1YWwodmFsMSwgcmVzdWx0LnZhbHVlLCBvcHRzLCBjaGFubmVsKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgJHNldERlbGV0ZShzZXQsIHJlc3VsdC52YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Jyb3dzZXJpZnkvY29tbW9uanMtYXNzZXJ0L2Jsb2IvYmJhODM4ZTliYTllMjhlZGYzMTI3Y2U2OTc0NjI0MjA4NTAyZjZiYy9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzI0w0MTYtTDQzOVxuZnVuY3Rpb24gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pIHtcbiAgaWYgKHR5cGVvZiBwcmltID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgcHJpbSA9PT0gJ29iamVjdCcpIHsgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcmltID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHByaW0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcmltID09PSAnbnVtYmVyJykge1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG8gYSByZWd1bGFyIG51bWJlciBhbmQgbm90IE5hTi5cbiAgICByZXR1cm4gK3ByaW0gPT09ICtwcmltOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Jyb3dzZXJpZnkvY29tbW9uanMtYXNzZXJ0L2Jsb2IvYmJhODM4ZTliYTllMjhlZGYzMTI3Y2U2OTc0NjI0MjA4NTAyZjZiYy9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzI0w0NDktTDQ2MFxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG9wdHMsIGNoYW5uZWwpIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhbHRWYWx1ZTtcbiAgfVxuICB2YXIgY3VyQiA9ICRtYXBHZXQoYiwgYWx0VmFsdWUpO1xuICB2YXIgbG9vc2VPcHRzID0gYXNzaWduKHt9LCBvcHRzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gIGlmIChcbiAgICAodHlwZW9mIGN1ckIgPT09ICd1bmRlZmluZWQnICYmICEkbWFwSGFzKGIsIGFsdFZhbHVlKSlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICB8fCAhaW50ZXJuYWxEZWVwRXF1YWwoaXRlbSwgY3VyQiwgbG9vc2VPcHRzLCBjaGFubmVsKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIHJldHVybiAhJG1hcEhhcyhhLCBhbHRWYWx1ZSkgJiYgaW50ZXJuYWxEZWVwRXF1YWwoaXRlbSwgY3VyQiwgbG9vc2VPcHRzLCBjaGFubmVsKTtcbn1cblxuLy8gdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYnJvd3NlcmlmeS9jb21tb25qcy1hc3NlcnQvYmxvYi9iYmE4MzhlOWJhOWUyOGVkZjMxMjdjZTY5NzQ2MjQyMDg1MDJmNmJjL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMjTDQ0MS1MNDQ3XG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuICRzZXRIYXMoYiwgYWx0VmFsdWUpICYmICEkc2V0SGFzKGEsIGFsdFZhbHVlKTtcbn1cblxuLy8gdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYnJvd3NlcmlmeS9jb21tb25qcy1hc3NlcnQvYmxvYi9iYmE4MzhlOWJhOWUyOGVkZjMxMjdjZTY5NzQ2MjQyMDg1MDJmNmJjL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMjTDUxOC1MNTMzXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgb3B0cywgY2hhbm5lbCkge1xuICB2YXIgaSA9IGdldEl0ZXJhdG9yKHNldCk7XG4gIHZhciByZXN1bHQ7XG4gIHZhciBrZXkyO1xuICB3aGlsZSAoKHJlc3VsdCA9IGkubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBrZXkyID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgaW50ZXJuYWxEZWVwRXF1YWwoa2V5MSwga2V5Miwgb3B0cywgY2hhbm5lbClcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgJiYgaW50ZXJuYWxEZWVwRXF1YWwoaXRlbTEsICRtYXBHZXQobWFwLCBrZXkyKSwgb3B0cywgY2hhbm5lbClcbiAgICApIHtcbiAgICAgICRzZXREZWxldGUoc2V0LCBrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgb3B0aW9ucywgY2hhbm5lbCkge1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChvcHRzLnN0cmljdCA/IGlzKGFjdHVhbCwgZXhwZWN0ZWQpIDogYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGFjdHVhbEJveGVkID0gd2hpY2hCb3hlZFByaW1pdGl2ZShhY3R1YWwpO1xuICB2YXIgZXhwZWN0ZWRCb3hlZCA9IHdoaWNoQm94ZWRQcmltaXRpdmUoZXhwZWN0ZWQpO1xuICBpZiAoYWN0dWFsQm94ZWQgIT09IGV4cGVjdGVkQm94ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCAodHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBpcyhhY3R1YWwsIGV4cGVjdGVkKSA6IGFjdHVhbCA9PSBleHBlY3RlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgfVxuXG4gIC8qXG4gICAqIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAgKiBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgICogd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAgKiAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gICAqIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gICAqIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICAgKi9cbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvZDNhYWZkMDJlZmQzYTQwM2Q2NDZhMzA0NGFkY2YxNGU2M2E4OGQzMiBmb3IgbWVtb3MvY2hhbm5lbCBpbnNwaXJhdGlvblxuXG4gIHZhciBoYXNBY3R1YWwgPSBjaGFubmVsLmhhcyhhY3R1YWwpO1xuICB2YXIgaGFzRXhwZWN0ZWQgPSBjaGFubmVsLmhhcyhleHBlY3RlZCk7XG4gIHZhciBzZW50aW5lbDtcbiAgaWYgKGhhc0FjdHVhbCAmJiBoYXNFeHBlY3RlZCkge1xuICAgIGlmIChjaGFubmVsLmdldChhY3R1YWwpID09PSBjaGFubmVsLmdldChleHBlY3RlZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZW50aW5lbCA9IHt9O1xuICB9XG4gIGlmICghaGFzQWN0dWFsKSB7IGNoYW5uZWwuc2V0KGFjdHVhbCwgc2VudGluZWwpOyB9XG4gIGlmICghaGFzRXhwZWN0ZWQpIHsgY2hhbm5lbC5zZXQoZXhwZWN0ZWQsIHNlbnRpbmVsKTsgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cywgY2hhbm5lbCk7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiB4LmNvbnN0cnVjdG9yLmlzQnVmZmVyKHgpKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgb3B0cywgY2hhbm5lbCkge1xuICBpZiAoJHNldFNpemUoYSkgIT09ICRzZXRTaXplKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpQSA9IGdldEl0ZXJhdG9yKGEpO1xuICB2YXIgaUIgPSBnZXRJdGVyYXRvcihiKTtcbiAgdmFyIHJlc3VsdEE7XG4gIHZhciByZXN1bHRCO1xuICB2YXIgc2V0O1xuICB3aGlsZSAoKHJlc3VsdEEgPSBpQS5uZXh0KCkpICYmICFyZXN1bHRBLmRvbmUpIHtcbiAgICBpZiAocmVzdWx0QS52YWx1ZSAmJiB0eXBlb2YgcmVzdWx0QS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICghc2V0KSB7IHNldCA9IG5ldyAkU2V0KCk7IH1cbiAgICAgICRzZXRBZGQoc2V0LCByZXN1bHRBLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEkc2V0SGFzKGIsIHJlc3VsdEEudmFsdWUpKSB7XG4gICAgICBpZiAob3B0cy5zdHJpY3QpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCByZXN1bHRBLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXNldCkgeyBzZXQgPSBuZXcgJFNldCgpOyB9XG4gICAgICAkc2V0QWRkKHNldCwgcmVzdWx0QS52YWx1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChzZXQpIHtcbiAgICB3aGlsZSAoKHJlc3VsdEIgPSBpQi5uZXh0KCkpICYmICFyZXN1bHRCLmRvbmUpIHtcbiAgICAgIC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeSBtYXRjaGluZyBhbmQgb25seSBpZiBpdCdzIG5vdCwgZ28gaHVudGluZyBmb3IgaXQuXG4gICAgICBpZiAocmVzdWx0Qi52YWx1ZSAmJiB0eXBlb2YgcmVzdWx0Qi52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCByZXN1bHRCLnZhbHVlLCBvcHRzLnN0cmljdCwgY2hhbm5lbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICFvcHRzLnN0cmljdFxuICAgICAgICAmJiAhJHNldEhhcyhhLCByZXN1bHRCLnZhbHVlKVxuICAgICAgICAmJiAhc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgcmVzdWx0Qi52YWx1ZSwgb3B0cy5zdHJpY3QsIGNoYW5uZWwpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHNldFNpemUoc2V0KSA9PT0gMDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgb3B0cywgY2hhbm5lbCkge1xuICBpZiAoJG1hcFNpemUoYSkgIT09ICRtYXBTaXplKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpQSA9IGdldEl0ZXJhdG9yKGEpO1xuICB2YXIgaUIgPSBnZXRJdGVyYXRvcihiKTtcbiAgdmFyIHJlc3VsdEE7XG4gIHZhciByZXN1bHRCO1xuICB2YXIgc2V0O1xuICB2YXIga2V5O1xuICB2YXIgaXRlbTE7XG4gIHZhciBpdGVtMjtcbiAgd2hpbGUgKChyZXN1bHRBID0gaUEubmV4dCgpKSAmJiAhcmVzdWx0QS5kb25lKSB7XG4gICAga2V5ID0gcmVzdWx0QS52YWx1ZVswXTtcbiAgICBpdGVtMSA9IHJlc3VsdEEudmFsdWVbMV07XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCFzZXQpIHsgc2V0ID0gbmV3ICRTZXQoKTsgfVxuICAgICAgJHNldEFkZChzZXQsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0yID0gJG1hcEdldChiLCBrZXkpO1xuICAgICAgaWYgKCh0eXBlb2YgaXRlbTIgPT09ICd1bmRlZmluZWQnICYmICEkbWFwSGFzKGIsIGtleSkpIHx8ICFpbnRlcm5hbERlZXBFcXVhbChpdGVtMSwgaXRlbTIsIG9wdHMsIGNoYW5uZWwpKSB7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBrZXksIGl0ZW0xLCBvcHRzLCBjaGFubmVsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNldCkgeyBzZXQgPSBuZXcgJFNldCgpOyB9XG4gICAgICAgICRzZXRBZGQoc2V0LCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQpIHtcbiAgICB3aGlsZSAoKHJlc3VsdEIgPSBpQi5uZXh0KCkpICYmICFyZXN1bHRCLmRvbmUpIHtcbiAgICAgIGtleSA9IHJlc3VsdEIudmFsdWVbMF07XG4gICAgICBpdGVtMiA9IHJlc3VsdEIudmFsdWVbMV07XG4gICAgICBpZiAoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbTIsIG9wdHMsIGNoYW5uZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAhb3B0cy5zdHJpY3RcbiAgICAgICAgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbnRlcm5hbERlZXBFcXVhbCgkbWFwR2V0KGEsIGtleSksIGl0ZW0yLCBvcHRzLCBjaGFubmVsKSlcbiAgICAgICAgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0yLCBhc3NpZ24oe30sIG9wdHMsIHsgc3RyaWN0OiBmYWxzZSB9KSwgY2hhbm5lbClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkc2V0U2l6ZShzZXQpID09PSAwO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzLCBjaGFubmVsKSB7XG4gIC8qIGVzbGludCBtYXgtc3RhdGVtZW50czogWzIsIDEwMF0sIG1heC1saW5lcy1wZXItZnVuY3Rpb246IFsyLCAxMjBdLCBtYXgtZGVwdGg6IFsyLCA1XSwgbWF4LWxpbmVzOiBbMiwgNDAwXSAqL1xuICB2YXIgaSwga2V5O1xuXG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmICgkb2JqVG9TdHJpbmcoYSkgIT09ICRvYmpUb1N0cmluZyhiKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoaXNBcmd1bWVudHMoYSkgIT09IGlzQXJndW1lbnRzKGIpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBhSXNBcnJheSA9IGlzQXJyYXkoYSk7XG4gIHZhciBiSXNBcnJheSA9IGlzQXJyYXkoYik7XG4gIGlmIChhSXNBcnJheSAhPT0gYklzQXJyYXkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gVE9ETzogcmVwbGFjZSB3aGVuIGEgY3Jvc3MtcmVhbG0gYnJhbmQgY2hlY2sgaXMgYXZhaWxhYmxlXG4gIHZhciBhSXNFcnJvciA9IGEgaW5zdGFuY2VvZiBFcnJvcjtcbiAgdmFyIGJJc0Vycm9yID0gYiBpbnN0YW5jZW9mIEVycm9yO1xuICBpZiAoYUlzRXJyb3IgIT09IGJJc0Vycm9yKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYUlzRXJyb3IgfHwgYklzRXJyb3IpIHtcbiAgICBpZiAoYS5uYW1lICE9PSBiLm5hbWUgfHwgYS5tZXNzYWdlICE9PSBiLm1lc3NhZ2UpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIH1cblxuICB2YXIgYUlzUmVnZXggPSBpc1JlZ2V4KGEpO1xuICB2YXIgYklzUmVnZXggPSBpc1JlZ2V4KGIpO1xuICBpZiAoYUlzUmVnZXggIT09IGJJc1JlZ2V4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoKGFJc1JlZ2V4IHx8IGJJc1JlZ2V4KSAmJiAoYS5zb3VyY2UgIT09IGIuc291cmNlIHx8IGZsYWdzKGEpICE9PSBmbGFncyhiKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYUlzRGF0ZSA9IGlzRGF0ZShhKTtcbiAgdmFyIGJJc0RhdGUgPSBpc0RhdGUoYik7XG4gIGlmIChhSXNEYXRlICE9PSBiSXNEYXRlKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYUlzRGF0ZSB8fCBiSXNEYXRlKSB7IC8vICYmIHdvdWxkIHdvcmsgdG9vLCBiZWNhdXNlIGJvdGggYXJlIHRydWUgb3IgYm90aCBmYWxzZSBoZXJlXG4gICAgaWYgKCRnZXRUaW1lKGEpICE9PSAkZ2V0VGltZShiKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfVxuICBpZiAob3B0cy5zdHJpY3QgJiYgZ1BPICYmIGdQTyhhKSAhPT0gZ1BPKGIpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBhV2hpY2ggPSB3aGljaFR5cGVkQXJyYXkoYSk7XG4gIHZhciBiV2hpY2ggPSB3aGljaFR5cGVkQXJyYXkoYik7XG4gIGlmIChhV2hpY2ggIT09IGJXaGljaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYVdoaWNoIHx8IGJXaGljaCkgeyAvLyAmJiB3b3VsZCB3b3JrIHRvbywgYmVjYXVzZSBib3RoIGFyZSB0cnVlIG9yIGJvdGggZmFsc2UgaGVyZVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhSXNCdWZmZXIgPSBpc0J1ZmZlcihhKTtcbiAgdmFyIGJJc0J1ZmZlciA9IGlzQnVmZmVyKGIpO1xuICBpZiAoYUlzQnVmZmVyICE9PSBiSXNCdWZmZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChhSXNCdWZmZXIgfHwgYklzQnVmZmVyKSB7IC8vICYmIHdvdWxkIHdvcmsgdG9vLCBiZWNhdXNlIGJvdGggYXJlIHRydWUgb3IgYm90aCBmYWxzZSBoZXJlXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGFJc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcihhKTtcbiAgdmFyIGJJc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcihiKTtcbiAgaWYgKGFJc0FycmF5QnVmZmVyICE9PSBiSXNBcnJheUJ1ZmZlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGFJc0FycmF5QnVmZmVyIHx8IGJJc0FycmF5QnVmZmVyKSB7IC8vICYmIHdvdWxkIHdvcmsgdG9vLCBiZWNhdXNlIGJvdGggYXJlIHRydWUgb3IgYm90aCBmYWxzZSBoZXJlXG4gICAgaWYgKGJ5dGVMZW5ndGgoYSkgIT09IGJ5dGVMZW5ndGgoYikpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICYmIGludGVybmFsRGVlcEVxdWFsKG5ldyBVaW50OEFycmF5KGEpLCBuZXcgVWludDhBcnJheShiKSwgb3B0cywgY2hhbm5lbCk7XG4gIH1cblxuICB2YXIgYUlzU0FCID0gaXNTaGFyZWRBcnJheUJ1ZmZlcihhKTtcbiAgdmFyIGJJc1NBQiA9IGlzU2hhcmVkQXJyYXlCdWZmZXIoYik7XG4gIGlmIChhSXNTQUIgIT09IGJJc1NBQikgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGFJc1NBQiB8fCBiSXNTQUIpIHsgLy8gJiYgd291bGQgd29yayB0b28sIGJlY2F1c2UgYm90aCBhcmUgdHJ1ZSBvciBib3RoIGZhbHNlIGhlcmVcbiAgICBpZiAoc2FiQnl0ZUxlbmd0aChhKSAhPT0gc2FiQnl0ZUxlbmd0aChiKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicgJiYgaW50ZXJuYWxEZWVwRXF1YWwobmV3IFVpbnQ4QXJyYXkoYSksIG5ldyBVaW50OEFycmF5KGIpLCBvcHRzLCBjaGFubmVsKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlcyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIHRoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy8gfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gIH1cblxuICAvLyBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZCB+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFpbnRlcm5hbERlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cywgY2hhbm5lbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIH1cblxuICB2YXIgYUNvbGxlY3Rpb24gPSB3aGljaENvbGxlY3Rpb24oYSk7XG4gIHZhciBiQ29sbGVjdGlvbiA9IHdoaWNoQ29sbGVjdGlvbihiKTtcbiAgaWYgKGFDb2xsZWN0aW9uICE9PSBiQ29sbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYUNvbGxlY3Rpb24gPT09ICdTZXQnIHx8IGJDb2xsZWN0aW9uID09PSAnU2V0JykgeyAvLyBhQ29sbGVjdGlvbiA9PT0gYkNvbGxlY3Rpb25cbiAgICByZXR1cm4gc2V0RXF1aXYoYSwgYiwgb3B0cywgY2hhbm5lbCk7XG4gIH1cbiAgaWYgKGFDb2xsZWN0aW9uID09PSAnTWFwJykgeyAvLyBhQ29sbGVjdGlvbiA9PT0gYkNvbGxlY3Rpb25cbiAgICByZXR1cm4gbWFwRXF1aXYoYSwgYiwgb3B0cywgY2hhbm5lbCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgb3B0cykge1xuICByZXR1cm4gaW50ZXJuYWxEZWVwRXF1YWwoYSwgYiwgb3B0cywgZ2V0U2lkZUNoYW5uZWwoKSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/deep-equal/index.js\n");

/***/ })

};
;